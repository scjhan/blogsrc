---
title: 【转】Actor模型和CSP模型的区别
toc: true
comments: true
date: 2017-07-15 16:30:46
tags:
	- csp
	- channel
categories: 
	- 并发编程
	- Go
---

## 1 Akka/Erlang Actor模型

Actors模型(Actor model)首先是由Carl Hewitt在1973定义，由Erlang OTP (Open Telecom Platform) 推广，其 消息传递更加符合面向对象的原始意图。 Actors属于并发组件模型 ，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。

<!--more-->

 传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors使用消息模型，每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors，保证了**单独写原则**，从而巧妙避免了多线程写争夺。Actors模型的特点是：

- 隔离计算实体
- "Share nothing"
- 没有任何地方同步
- 异步消息传递
- 不可变的消息 消息模型类似mailbox / queue

Actors是一个轻量级的对象，通过发送消息实现交互。每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors。在同一时间可以于一个Java虚拟机存在数以百万计的参与者，构架是一个分层的父层（管理） - 子层，其中父层监控子层的行为。还可以很容易地扩展Actor运行在集群中各个节点之间 - 无需修改一行代码。每个演员都可以有内部状态（字段/变量） ，但通信只能通过消息传递，不会有共享数据结构（计数器，队列） 。Akka框架支持两种语言Java和Scala，

在Actor模型中，主角是Actor，类似一种worker，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理的：

![](/uploads/actors.png)

Actor模型描述了一组为了避免并发编程的常见问题的公理:

- 所有Actor状态是Actor本地的，外部无法访问。
- Actor必须只有通过消息传递进行通信。
- 一个Actor可以响应消息:推出新Actor,改变其内部状态,或将消息发送到一个或多个其他参与者。
- Actor可能会堵塞自己,但Actor不应该堵塞它运行的线程。

## 2 CSP- Channel模型

CSP模型是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。

Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。

![](/uploads/channel.png)

Go语言的CSP模型是由协程Goroutine与通道Channel实现：

- Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。
- 通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。

## 3 Actor模型和CSP区别

Actor模型和CSP区别图如下：

![](/uploads/actorVScsp.png)

Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。

同时，它们都是描述独立的进程通过消息传递进行通信。主要的区别在于：在CSP消息交换是同步的(即两个进程的执行"接触点"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立,因为他可以根据自己的状态选择处理哪个传入消息。自主性更大些。

在Go语言中为了不堵塞进程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。

