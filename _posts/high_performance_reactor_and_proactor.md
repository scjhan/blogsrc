---
title: 两种高性能I/O模式：Reactor和Proactor
toc: true
date: 2017-05-05 22:41:41
tags:
	- reactor
	- proactor
categories: 网络编程
---
系统I/O 可分为阻塞型，非阻塞同步型以及非阻塞异步型。
<!--more-->
1. 阻塞型I/O意味着控制权只到调用操作结束了才会回到调用者手里。 结果调用者被阻塞了， 这段时间了做不了任何其它事情。在等待IO结果的时间里，调用者所在线程此时无法腾出手来去响应其它的请求，非常浪费资源了。例如read()系统调用，调用他的函数会一直阻塞在read()上直到socket可读。
2. 相比之下，非阻塞同步是会立即返回控制权给调用者的。调用者不需要等待，它从调用的函数获取两种结果：要么此次调用成功进行了;要么系统返回错误标识告诉调用者当前资源不可用。例如read()系统调用， 如果当前socket无数据可读，则立即返回`EWOULBLOCK/EAGAIN`，告诉read()的调用者”数据还没准备好，你稍后再试”。
3. 在非阻塞异步调用中，稍有不同。调用函数在立即返回时，还告诉调用者，这次请求已经开始了。系统会使用另外的资源或者线程来完成这次调用操作，并在完成的时候知会调用者（比如通过回调函数）。

在以上三种IO形式中，非阻塞异步是性能最高、伸缩性最好的。

****
一般情况下，I/O 复用机制需要事件分发器(event demultiplexor)。事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者。开发人员在开始的时候需要在事件分发器那里注册感兴趣的事件（如可读或者可写），并提供相应的处理者(event handlers)，或者是回调函数(event callback); 事件分发器在适当的时候会将请求的事件分发给这些handler或者callback。

事件分发器主要有两种模式：Reactor和Proactor。
1. **Reactor模式**
他是基于同步I/O的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。
2. **Proactor模式**
他是基于异步I/O的。在Proactor模式中，handler直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的handler或者callback。

Reactor模式简单例子：
- 某个handler宣称对某个socket的某个事件感兴趣
- 事件分发器等待这个事件的发生
- 这个事件发生，事件分发器被唤醒并通知对应的handler
- handler进行相关操作

Proactor模式简单例子：
- handler投递一个异步写（读）操作，事件分发器只关心这个请求，不关心读（写）事件。
- 事件分发器等待这个事件的完成
- 这个事件完成了（操作系统异步完成），操作系统通知事件分发器，然后事件分发器通知对应的handler
